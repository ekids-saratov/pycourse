import random
import time
import turtle
from typing import List

# Конфигурируем экран программы, задаем начальные свойства
window = turtle.Screen()  # Создаем экземпляр класса (объект) Screen и прискаеваем его в переменную window
window.title('Snake Game')  # Задаем заголовок окна
window.bgcolor('#8b1c71')  # Задаем цвет фона окна
window.setup(width=600, height=600)  # задаем ширину и высоту окна
window.tracer(0)  # отключаем перерисовку
window.bgpic("background.png") # Можно положить в папку с кодом программы png картинку размером 600x600 и использовать ее как фон окна.

delay = 1 / 10  # частота обновления экрана или паузу между перерисовками экрана

# голова змейки
head = turtle.Turtle('square')  # Создаем новый объект "Черепаха"
head.direction = 'stop'  # Добавляем ему поле direction где будем хранить текущее направление змейки
head.penup()  # этот метод отлючает отрисовку линии вслед за движение "Черепахи"
head.pencolor("green")  # Задаем цвет контура
head.fillcolor("black")  # Задаем цвет заливки
# head.color("green", "black") # Оба цвета можно задать также используя метод color

# Создание яблока
apple = turtle.Turtle("square")
apple.penup()
apple.pencolor("black")
apple.fillcolor("red")
# apple.color("black", "red")
apple.speed(0)
apple.goto(100, 100)


# Функция перемещает яблоко в новые координаты кратно размеру одного квадратика на поле
def move_apple_to_random_position():
    # размеры экрана 600х600
    # размеры квадратика (голова змейки, яблоко, часть хвоста) 20
    # потому ±600/2-20 = ±280
    # фунцкия randrange принимает от 2 до трех чисел: первое это нижняя граница диапазона, второе число это верхняя граница диапазона(исключительно) и третье число это шаг с которым будут браться числа в этом диапазоне
    rand_x = random.randrange(-280, 280 + 1, 20) # рандом в диапазоне от -280 до 281 с шагом в 20 (верхняя граница 281 не вклячается в диапазон
    # говорят нижняя граница "включительно" и верхняя граница "исключительно" - это значит диапазон случайных чисел получится от -280 до 280 (т.к 281 не включена в него)
    rand_y = random.randrange(-280, 280 + 1, 20)
    apple.goto(rand_x, rand_y)
    # print("rand_x: {}, rand_y: {}".format(rand_x, rand_y))  #  Использую print для отладки - проверки возможных значений координат яблока - в готовой версии программы эта строка НЕ НУЖНА

# Тут начинаются функции меняющие направление Змейки.
# Само по себе поле direction содержит лишь строку - название направления, например up или left
# Есть правило: Если Змейка едет влево, она не может развернуться и поехать вправо иначе она въедет в свой хвост, тоже для верх/низ направлений
def go_up():
    if head.direction != "down":
        head.direction = "up"


def go_down():
    if head.direction != "up":
        head.direction = "down"


def go_left():
    if head.direction != "right":
        head.direction = "left"


def go_right():
    if head.direction != "left":
        head.direction = "right"


# Это функция меняет одну из координат головы Змейки на расстояние равное размеру головы (или любой клетки игрового поля) - 20px
def move():
    if head.direction == "up":
        y = head.ycor()  # метод ycor возвращает y координату головы
        head.sety(y + 20)

    if head.direction == "down":
        head.sety(head.ycor() - 20)  # Так можно немного оптимизировать код убрав одну строку

    if head.direction == "left":
        x = head.xcor()  # метод xcor возвращает x координату головы
        head.setx(x - 20)

    if head.direction == "right":
        head.setx(head.xcor() + 20)


# Создаем коллекцию (список) в котором будем хранить сегменты (квадратики) хвоста
segments = []  # type:List[turtle.Turtle] # Указываем объект какого типа будет храниться в списке


# Эта функция создает новый объект "Черепаха" который будет являться сегментом хвоста Змейки
def create_new_segment():
    new_segment = turtle.Turtle()  # Создаем новый объект "Черепаха". НЕ ЗАБЫВАЙТЕ СТАВИТЬ КРУГЛЫЕ СКОБКИ ПОСЛЕ .Turtle
    # Задаем скорость анимации
    new_segment.speed(0)  # в данном случае отключаем анимацию рисования линии и поворота "Черепахи" Это ускоряет выполнение кода
    new_segment.shape("square")
    new_segment.fillcolor("grey") # Цвета можно задавать динамически, тогда каждый новый сегмент будет отличаться
    new_segment.pencolor(head.pencolor()) # Возьми такойже цвет контура как и у головы Змейки
    new_segment.penup()  # Не будем рисовать линию при перемещении "Черепахи"
    return new_segment


# Эта функция добавляет новый сегмент в список сегментов
def add_segment():
    segments.append(create_new_segment())


# Эта функция сдвигает сегменты хвоста на новое положение
# Запоминаются текущие координаты сегмента ему присваиваются координаты предидущего сегмента , а первому сегменту присваиваются координаты головы Змейки
def segment_shift(head_x, head_y):
    prev_x = head_x  # prev - previous предидущий
    prev_y = head_y
    for segment in segments:
        curr_x = segment.xcor()  # curr - current текущий
        curr_y = segment.ycor()
        segment.goto(prev_x, prev_y)
        prev_x = curr_x
        prev_y = curr_y


# Тут связываем нажатия клавишь клавиатуры с вызовом функций для управления Змейкой
window.listen()  # эта функция влкючает прослушивание нажатий клавиатуры и мыши
window.onkeypress(go_up, "Up")  # когда клавиша Вверх нажата вызови функцию go_up
window.onkeypress(go_down, "Down")
window.onkeypress(go_left, "Left")
window.onkeypress(go_right, "Right")
# window.onkeypress(add_segment, "space") # Тат можно потестировать добавление новых сегментов хвоста нажимая на пробел


# Функция проверяет столкнулась ли голова Змейки с яблоком и если да то добавляет Змейке новый сегмент хвоста и перемещает яблоко в новое место
# Раньше эта функция называлась on_collision(), но сейчас стало много collision - сталкновений,для ясности переименовал в
def check_apple_collision():
    if head.distance(apple) < 20: # если дистанция между head (головой) и яблоком меньше 20 (размера одного квадратика на поле), значит они в одном месте, то есть столкнулись
        add_segment()
        move_apple_to_random_position()
        global delay # используем переменную определенную в основной части программы - в глобальном скоупе
        delay -= 0.01 # Уменьшаем переменную паузы между перерисовками экрана - таким образом ускоряем Змейку с каждым съеденным яблоком

# Функция удаляет все сегменты хвоста, перемещает голову Змейки в точку (0,0) и печатает надпись о проигроше
def game_over():
    score = str(len(segments)) # Запоминаем сколько было сегментов в хвосте или сколько яблок съела Змейка. Функция len возвращает длинну списка, а функция str преобразует число в строку
    for segment in segments: # Обойди все сегменты в списке segments и спряч каждый из них
        segment.hideturtle() # спряч
    segments.clear() # удаляем все элементы в списке сегментов хвоста
    head.home() # Отправляем голову Зммейки в координаты (0,0)
    head.direction = "stop" # Останавливаем голову Змейки
    head.write("Game over\n Your score:"+score, align="center", font=("Arial", 30, "normal")) # Выводим надпись о проигроше на экран
    time.sleep(2) # Ждем 2 секунду
    head.clear() # Стираем надпись
    global delay # используем переменную определенную в основной части программы - в глобальном скоупе
    delay = 1 / 10 # Возвращаем начальное значение скорости перерисовки экрана


# Функция проверяет столкновение Змейки с границами экрана
def check_border_collision():
    # Змейка столкнулась с левым или правым краем ИЛИ с верхним или нижним краем игрового поля
    if head.xcor() > 300 or head.xcor() < -300 or head.ycor() > 300 or head.ycor() < -300:
        # также можно записать устоловие выше, объединив пары условийвот так:   -300 < head.xcor() > 300 or -300 < head.ycor() > 300
        game_over()

# Функция проверяет столкновение головы Змейки с её хвостом
def check_tail_collision():
    for segment in segments:
        if head.distance(segment) < 20: # если дистанция между head (головой) и сегментом хвоста меньше 20 - размера сегмента, значит они в одном месте, то есть столкнулись
            game_over()


# Остновно игровой цикл состоит из
while True:
    segment_shift(head.xcor(), head.ycor())  # изменения положения сегментов хвоста
    move()  # изменения положения головы
    check_apple_collision()  # проверка столкновения с яблоком
    check_border_collision() # проверка столкновения с границами экрана
    check_tail_collision() # проверка столкновения с хвостом
    window.update()  # обновления экрана
    time.sleep(delay)  # вызова паузы между перерисовками экрана, чтоб контролировать скорость анимации
